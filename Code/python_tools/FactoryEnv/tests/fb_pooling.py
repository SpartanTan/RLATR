import numpy as np
import time

min_bound = -np.deg2rad(120)
max_bound = np.deg2rad(120)
r = np.deg2rad(3) # resolution
sensor_angles = np.linspace(min_bound, max_bound, int(np.rint(abs((max_bound - min_bound) / r))))
sensor_angles = np.round(sensor_angles, 3)
# print(np.rad2deg(sensor_angles))
# print(np.rad2deg(sensor_angles.reshape((20, 4))))
# data = [(-2.094, 0.048798421601617216), (-2.042, 0.05007174168422446), (-1.99, 0.051598483526927426), (-1.937, 0.05345878160156304), (-1.885, 0.05563949618954267), (-1.833, 0.05824955734018409), (-1.78, 0.0614634541393452), (-1.728, 0.065320098902461), (-1.676, 0.07011753003917101), (-1.623, 0.07639307503282132), (-1.571, 0.08467314262886041), (-1.518, 0.09706766823925564), (-1.466, 0.11958559303069345), (-1.414, 1.0), (-1.361, 1.0), (-1.309, 1.0), (-1.257, 1.0), (-1.204, 1.0), (-1.152, 1.0), (-1.1, 1.0), (-1.047, 1.0), (-0.995, 1.0), (-0.942, 1.0), (-0.89, 1.0), (-0.838, 1.0), (-0.785, 1.0), (-0.733, 1.0), (-0.681, 0.29425698809074), (-0.628, 0.2659912999672283), (-0.576, 0.24820358156704525), (-0.524, 0.23541374282013), (-0.471, 0.22564892461490282), (-0.419, 0.218360351789268), (-0.367, 0.21282223005925557), (-0.314, 0.17839108703648904), (-0.262, 0.15612875482612645), (-0.209, 0.14185616426330622), (-0.157, 0.1317866981166215), (-0.105, 0.12408013206278129), (-0.052, 0.11788739628082284), (0.0, 0.11301087977960964), (0.052, 0.1090547044427776), (0.105, 0.10578661707770032), (0.157, 0.10320568594248472), (0.209, 0.10115701573310404), (0.262, 0.09955247295657037), (0.314, 0.09840788322669503), (0.367, 0.09764782679452158), (0.419, 0.09728186884160483), (0.471, 0.09728294332245482), (0.524, 0.09766179794663808), (0.576, 0.09841343325859728), (0.628, 0.09956042331172096), (0.681, 0.10116763392095346), (0.733, 0.10321923148931778), (0.785, 0.10580351922764453), (0.838, 0.10907564641037718), (0.89, 0.11303664942525699), (0.942, 0.11791924983244592), (0.995, 0.12412017861085048), (1.047, 0.13183801936154593), (1.1, 0.14214979321295224), (1.152, 0.15622861544365652), (1.204, 0.17856859286191085), (1.257, 1.0), (1.309, 1.0), (1.361, 1.0), (1.414, 1.0), (1.466, 1.0), (1.518, 1.0), (1.571, 1.0), (1.623, 1.0), (1.676, 1.0), (1.728, 1.0), (1.78, 1.0), (1.833, 1.0), (1.885, 1.0), (1.937, 1.0), (1.99, 1.0), (2.042, 1.0), (2.094, 1.0)]
data = [(-2.042, 0.05007174168422446), (-1.99, 0.051598483526927426), (-1.937, 0.05345878160156304), (-1.885, 0.05563949618954267), (-1.833, 0.05824955734018409), (-1.78, 0.0614634541393452), (-1.728, 0.065320098902461), (-1.676, 0.07011753003917101), (-1.623, 0.07639307503282132), (-1.571, 0.08467314262886041), (-1.518, 0.09706766823925564), (-1.466, 0.11958559303069345), (-1.414, 1.0), (-1.361, 1.0), (-1.309, 1.0), (-1.257, 1.0), (-1.204, 1.0), (-1.152, 1.0), (-1.1, 1.0), (-1.047, 1.0), (-0.995, 1.0), (-0.942, 1.0), (-0.89, 1.0), (-0.838, 1.0), (-0.785, 1.0), (-0.733, 1.0), (-0.681, 0.29425698809074), (-0.628, 0.2659912999672283), (-0.576, 0.24820358156704525), (-0.524, 0.23541374282013), (-0.471, 0.22564892461490282), (-0.419, 0.218360351789268), (-0.367, 0.21282223005925557), (-0.314, 0.17839108703648904), (-0.262, 0.15612875482612645), (-0.209, 0.14185616426330622), (-0.157, 0.1317866981166215), (-0.105, 0.12408013206278129), (-0.052, 0.11788739628082284), (0.0, 0.11301087977960964), (0.052, 0.1090547044427776), (0.105, 0.10578661707770032), (0.157, 0.10320568594248472), (0.209, 0.10115701573310404), (0.262, 0.09955247295657037), (0.314, 0.09840788322669503), (0.367, 0.09764782679452158), (0.419, 0.09728186884160483), (0.471, 0.09728294332245482), (0.524, 0.09766179794663808), (0.576, 0.09841343325859728), (0.628, 0.09956042331172096), (0.681, 0.10116763392095346), (0.733, 0.10321923148931778), (0.785, 0.10580351922764453), (0.838, 0.10907564641037718), (0.89, 0.11303664942525699), (0.942, 0.11791924983244592), (0.995, 0.12412017861085048), (1.047, 0.13183801936154593), (1.1, 0.14214979321295224), (1.152, 0.15622861544365652), (1.204, 0.17856859286191085), (1.257, 1.0), (1.309, 1.0), (1.361, 1.0), (1.414, 1.0), (1.466, 1.0), (1.518, 1.0), (1.571, 1.0), (1.623, 1.0), (1.676, 1.0), (1.728, 1.0), (1.78, 1.0), (1.833, 1.0), (1.885, 1.0), (1.937, 1.0), (1.99, 1.0), (2.042, 1.0), (2.094, 1.0)]

mes = np.array(data)
mes = mes[:, 1]
mes = mes.reshape((20, 4))
print(mes)
W = 0.48
N = sensor_angles.shape[0]
Ss = np.deg2rad(240)
# print(span)
theta = Ss / (N - 1)
print(np.rad2deg(theta))


def feasibility_pooling(x):
    I = np.argsort(x)
    for i in I:
        # calculate arc-length
        di = theta * x[i]
        # calculate opening-width
        y = di / 2
        # initialize opening found flag
        si = False

        for j, xj in enumerate(x):
            if xj > x[i]:
                y += di
                if y > W:
                    si = True
                    break
                else:
                    y += di / 2
                    if y > W:
                        si = True
                        break
                y = 0
                
        if si is False:
            return x[i]

    # return None if no feasible solution found
    return None

def feasibility_pooling1(x):
    """fastest"""
    # sort x in ascending order
    sorted_x = np.sort(x)

    # for each value xi in sorted x
    for xi in sorted_x:
        di = theta * xi  # calculate arc-length
        y = di / 2  # calculate opening-width
        si = False  # initialize opening found flag

        # for each value xj in x
        for xj in x:
            if xj > xi:
                y += di
                if y > W:
                    si = True
                    break
                else:
                    y += di / 2
                    if y > W:
                        si = True
                        break
                y = 0

        # if si is False for all xj in x, return xi
        if not si:
            return xi

    # return None if no feasible solution found
    return None

def feasibility_pooling2(x):
    sorted_x = np.sort(x)
    for xi in sorted_x:
        di = theta * xi
        y = np.cumsum(np.where(x > xi, di, di / 2))
        if not np.any(y > W):
            return xi
    return None

start_time = time.time()
results = []
for i in range(10000):
    results = []
    for i, x in enumerate(mes):
        results.append(feasibility_pooling(x))
print(results)
print(f"end time: {time.time() - start_time}")

start_time = time.time()
results = []
for i in range(10000):
    results = []
    for i, x in enumerate(mes):
        results.append(feasibility_pooling1(x))
print(results)
print(f"end time: {time.time() - start_time}")

start_time = time.time()
results = []
for i in range(10000):
    results = []
    for i, x in enumerate(mes):
        results.append(feasibility_pooling2(x))
print(results)
print(f"end time: {time.time() - start_time}")